# Pitch Detection {#pitch-detection}

This tutorial compares two classic fundamental-frequency (F0) estimators:

- **Autocorrelation peak picking** (time domain)
- **FFT peak picking** (frequency domain)

Both are implemented in miniDSP and demonstrated in
`examples/pitch_detection.c`.

Build and run the example from the repository root:

```sh
make -C examples pitch_detection
cd examples && ./pitch_detection
open pitch_detection.html
```

---

## Autocorrelation F0

For a voiced frame, the fundamental period shows up as a strong peak in
the autocorrelation function:

\f[
R[\tau] = \frac{\sum_{n=0}^{N-1-\tau} x[n]x[n+\tau]}
               {\sum_{n=0}^{N-1} x[n]^2},
\qquad
f_0 = \frac{f_s}{\tau_{\text{peak}}}
\f]

We search only lags mapped from a desired F0 range
(`min_freq_hz..max_freq_hz`), then choose the strongest local peak.

### Reading the algorithm in C

\snippet pitch_detection.c acf-reading-algorithm

---

## FFT-based F0

This method applies a Hann window, computes the one-sided FFT magnitude,
and picks the dominant peak in a frequency range:

\f[
f_0 = \frac{k_{\text{peak}} f_s}{N}
\f]

It is simple and fast, but more sensitive to noise and harmonic dominance
than autocorrelation.

### Reading the algorithm in C

\snippet pitch_detection.c fft-reading-algorithm

---

## Frame-Wise Tracking

In practice, pitch is estimated frame-by-frame over time:

\snippet pitch_detection.c frame-tracking

---

## Visual Comparison

\htmlonly
<p><strong>Ground truth vs estimated tracks (entire signal)</strong></p>
<iframe src="pitch_f0_tracks.html"
        style="width:100%;height:390px;border:1px solid #ddd;border-radius:4px;"
        frameborder="0"></iframe>

<p style="margin-top:0.8rem;"><strong>Autocorrelation peak (single frame)</strong></p>
<iframe src="pitch_acf_peak_frame.html"
        style="width:100%;height:390px;border:1px solid #ddd;border-radius:4px;"
        frameborder="0"></iframe>

<p style="margin-top:0.8rem;"><strong>FFT peak pick (single frame)</strong></p>
<iframe src="pitch_fft_peak_frame.html"
        style="width:100%;height:390px;border:1px solid #ddd;border-radius:4px;"
        frameborder="0"></iframe>
\endhtmlonly

---

## Failure Modes and Trade-offs

- **Autocorrelation** can fail on weakly voiced/noisy frames where no clear
  lag peak exists.
- **FFT peak pick** can lock onto harmonics (e.g. 2f0, 3f0) when the
  fundamental is weak.
- Restricting the search range (`min_freq_hz`, `max_freq_hz`) is critical for
  both methods.
- Short frames improve time resolution but reduce frequency/lag resolution.

Both miniDSP APIs return `0.0` when no reliable F0 peak is found.

---

## Implementation Learnings

- FFT-dependent APIs are implemented in the spectrum module
  (`src/minidsp_spectrum.c`), while time-domain/stateless analysis stays in
  `src/minidsp_core.c`.
- API behavior is consistent with the rest of miniDSP:
  assertions for invalid usage, sentinel `0.0` for valid-but-unresolved F0.
- Equation-heavy sections should include a corresponding
  **Reading the algorithm in C** snippet.
- New tutorial visuals are generated by the docs pipeline
  (`examples/gen_signal_plots.c` + `Doxyfile`), keeping docs reproducible.

---

## API Reference

- MD_f0_autocorrelation() -- F0 from autocorrelation peak
- MD_f0_fft() -- F0 from Hann-windowed FFT magnitude peak
- MD_shutdown() -- release cached FFT plans/resources when done
