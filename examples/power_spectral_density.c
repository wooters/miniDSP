/**
 * @file power_spectral_density.c
 * @brief Example: compute and export the power spectral density of a test signal.
 *
 * This program demonstrates MD_power_spectral_density() by:
 *   1. Generating a signal with three sinusoidal components (440 Hz,
 *      1000 Hz, and 2500 Hz) plus a DC offset.
 *   2. Applying a Hanning window to reduce spectral leakage.
 *   3. Computing the PSD via MD_power_spectral_density().
 *   4. Converting to a one-sided PSD (doubling interior bins).
 *   5. Writing the results to CSV and to an interactive HTML visualisation
 *      (Plotly.js + D3.js, no server required).
 *
 * The PSD shows how the signal's *power* is distributed across frequencies,
 * whereas the magnitude spectrum shows *amplitude*.  PSD is especially
 * useful for noise analysis and SNR estimation.
 *
 * Build and run (from the repository root):
 *   make                          # build libminidsp.a first
 *   make -C examples plot         # build example, run it, generate HTML
 *   open examples/power_spectral_density.html   # interactive PSD plot
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "minidsp.h"
#include "plot_html.h"

/* -----------------------------------------------------------------------
 * Write the interactive HTML visualisation.
 *
 * The HTML file is completely self-contained: PSD data is embedded
 * as JavaScript arrays, and Plotly.js / D3.js are loaded from CDN.
 * Just open the file in any modern browser -- no local server needed.
 * -----------------------------------------------------------------------*/
static int write_html(const char *path,
                      const double *freqs, const double *psd,
                      unsigned num_bins,
                      double sample_rate, unsigned N,
                      double freq1, double freq2, double freq3)
{
    FILE *fp = fopen(path, "w");
    if (!fp) {
        fprintf(stderr, "cannot open %s for writing\n", path);
        return -1;
    }

    char subtitle[256];
    snprintf(subtitle, sizeof(subtitle),
        "%.0f Hz + %.0f Hz + %.0f Hz &nbsp;|&nbsp;\n"
        "    sample rate %.0f Hz &nbsp;|&nbsp;\n"
        "    FFT size %u &nbsp;|&nbsp;\n"
        "    Hanning window",
        freq1, freq2, freq3, sample_rate, N);

    plot_html_begin(fp, "Power Spectral Density", subtitle, 1);

    fprintf(fp,
        "  <div id=\"linear-plot\" class=\"plot-container\"></div>\n"
        "  <div id=\"db-plot\" class=\"plot-container\"></div>\n"
        "  <div class=\"info\">\n"
        "    <strong>How to read this plot:</strong><br>\n"
        "    The PSD shows how signal <em>power</em> is distributed across\n"
        "    frequencies.  Each spike corresponds to a sinusoidal component.\n"
        "    The x-axis shows frequency in Hz (bin index &times;\n"
        "    <code>sample_rate / N</code>).  The top plot uses a linear power\n"
        "    scale; the bottom plot uses a logarithmic (dB) scale\n"
        "    (<code>10&middot;log10(PSD)</code>) so you can see low-level details.\n"
        "    Note: PSD uses <code>10&middot;log10</code> (not 20) because it\n"
        "    represents power, not amplitude.\n"
        "  </div>\n\n");

    /* ---- Embed PSD data as JS arrays ---- */
    fprintf(fp, "  <script>\n");
    fprintf(fp, "    // PSD data generated by power_spectral_density.c\n");
    plot_html_js_array(fp, "freqs", freqs, num_bins, "%.4f");
    plot_html_js_array(fp, "psd", psd, num_bins, "%.8f");
    fprintf(fp, "\n");

    /* ---- Plotly + D3 visualisation code ---- */
    fprintf(fp,
        "    // Use D3's d3.max() to compute axis ranges\n"
        "    const maxPSD = d3.max(psd);\n"
        "\n"
        "    // Convert to dB scale: 10*log10(PSD) because PSD is power, not amplitude.\n"
        "    // Floor at -120 dB to avoid log(0).\n"
        "    const psd_db = psd.map(p => 10 * Math.log10(Math.max(p, 1e-12)));\n"
        "\n"
        "    // Find the three peak frequencies for annotation using d3\n"
        "    const peakTargets = [%.0f, %.0f, %.0f];\n"
        "    const annotations_linear = [];\n"
        "    const annotations_db = [];\n"
        "\n"
        "    peakTargets.forEach(target => {\n"
        "      const idx = d3.minIndex(freqs, f => Math.abs(f - target));\n"
        "      annotations_linear.push({\n"
        "        x: freqs[idx], y: psd[idx],\n"
        "        text: target + ' Hz',\n"
        "        showarrow: true, arrowhead: 2,\n"
        "        ax: 40, ay: -30,\n"
        "        font: { size: 12 }\n"
        "      });\n"
        "      annotations_db.push({\n"
        "        x: freqs[idx], y: psd_db[idx],\n"
        "        text: target + ' Hz (' + psd_db[idx].toFixed(1) + ' dB)',\n"
        "        showarrow: true, arrowhead: 2,\n"
        "        ax: 50, ay: -25,\n"
        "        font: { size: 12 }\n"
        "      });\n"
        "    });\n"
        "\n"
        "    // --- Linear PSD plot ---\n"
        "    Plotly.newPlot('linear-plot', [{\n"
        "      x: freqs, y: psd,\n"
        "      type: 'scatter', mode: 'lines',\n"
        "      line: { color: '#2563eb', width: 1.2 },\n"
        "      name: 'PSD',\n"
        "      hovertemplate: '%%{x:.1f} Hz<br>Power: %%{y:.6f}<extra></extra>'\n"
        "    }], {\n"
        "      title: { text: 'Linear Scale', font: { size: 15 } },\n"
        "      xaxis: { title: 'Frequency (Hz)', range: [0, d3.max(freqs)] },\n"
        "      yaxis: { title: 'Power', range: [0, maxPSD * 1.1] },\n"
        "      annotations: annotations_linear,\n"
        "      margin: { t: 50, r: 30, b: 50, l: 60 },\n"
        "      height: 320\n"
        "    }, { responsive: true });\n"
        "\n"
        "    // --- dB PSD plot ---\n"
        "    Plotly.newPlot('db-plot', [{\n"
        "      x: freqs, y: psd_db,\n"
        "      type: 'scatter', mode: 'lines',\n"
        "      line: { color: '#dc2626', width: 1.2 },\n"
        "      name: '10\\u00b7log\\u2081\\u2080(PSD)',\n"
        "      hovertemplate: '%%{x:.1f} Hz<br>%%{y:.1f} dB<extra></extra>'\n"
        "    }], {\n"
        "      title: { text: 'Logarithmic (dB) Scale', font: { size: 15 } },\n"
        "      xaxis: { title: 'Frequency (Hz)', range: [0, d3.max(freqs)] },\n"
        "      yaxis: { title: 'Power (dB)', range: [-80, 5] },\n"
        "      annotations: annotations_db,\n"
        "      margin: { t: 50, r: 30, b: 50, l: 60 },\n"
        "      height: 320\n"
        "    }, { responsive: true });\n"
        "  </script>\n",
        freq1, freq2, freq3);

    plot_html_end(fp);
    fclose(fp);
    return 0;
}

int main(void)
{
    /* ------------------------------------------------------------------
     * Signal parameters
     * ----------------------------------------------------------------*/
    const unsigned   N           = 4096;        /* FFT size (samples)       */
    const double     sample_rate = 16000.0;     /* Hz                       */
    const unsigned   num_bins    = N / 2 + 1;   /* unique frequency bins    */

    /* Three tones at different amplitudes, plus a small DC offset */
    const double     freq1 =  440.0;   /* A4 note               */
    const double     amp1  =    1.0;
    const double     freq2 = 1000.0;   /* 1 kHz reference tone  */
    const double     amp2  =    0.6;
    const double     freq3 = 2500.0;   /* higher partial        */
    const double     amp3  =    0.3;
    const double     dc    =    0.1;   /* small DC offset       */

    /* ------------------------------------------------------------------
     * Generate the test signal
     * ----------------------------------------------------------------*/
    double *signal   = malloc(N * sizeof(double));
    double *windowed = malloc(N * sizeof(double));
    double *window   = malloc(N * sizeof(double));
    double *psd      = malloc(num_bins * sizeof(double));
    double *freqs    = malloc(num_bins * sizeof(double));

    if (!signal || !windowed || !window || !psd || !freqs) {
        fprintf(stderr, "allocation failed\n");
        return 1;
    }

    //! [generate-signal]
    double *tone = malloc(N * sizeof(double));
    for (unsigned i = 0; i < N; i++) signal[i] = dc;

    MD_sine_wave(tone, N, amp1, freq1, sample_rate);
    for (unsigned i = 0; i < N; i++) signal[i] += tone[i];

    MD_sine_wave(tone, N, amp2, freq2, sample_rate);
    for (unsigned i = 0; i < N; i++) signal[i] += tone[i];

    MD_sine_wave(tone, N, amp3, freq3, sample_rate);
    for (unsigned i = 0; i < N; i++) signal[i] += tone[i];

    free(tone);
    //! [generate-signal]

    /* ------------------------------------------------------------------
     * Apply a Hanning window to reduce spectral leakage.
     * Windowing tapers the signal edges to zero, preventing the abrupt
     * discontinuity at the FFT frame boundary from smearing energy
     * across all frequency bins.
     * ----------------------------------------------------------------*/
    //! [apply-window]
    MD_Gen_Hann_Win(window, N);
    for (unsigned i = 0; i < N; i++) {
        windowed[i] = signal[i] * window[i];
    }
    //! [apply-window]

    /* ------------------------------------------------------------------
     * Compute the power spectral density.
     * MD_power_spectral_density() returns PSD[k] = |X(k)|^2 / N.
     * The /N normalisation is already done inside the function.
     * ----------------------------------------------------------------*/
    //! [compute-psd]
    MD_power_spectral_density(windowed, N, psd);
    //! [compute-psd]

    /* Convert to one-sided PSD:
     *   - Double the interior bins (k = 1..N/2-1) because negative
     *     frequencies are folded onto the positive side.
     *   - DC (k=0) and Nyquist (k=N/2) are not doubled -- they have
     *     no mirror image.
     * Note: we do NOT divide by N again -- the function already did that. */
    //! [one-sided-psd]
    for (unsigned k = 0; k < num_bins; k++) {
        freqs[k] = (double)k * sample_rate / (double)N;
        if (k > 0 && k < N / 2) {
            psd[k] *= 2.0;
        }
    }
    //! [one-sided-psd]

    /* ------------------------------------------------------------------
     * Write results to CSV (for data interchange)
     * ----------------------------------------------------------------*/
    const char *csv_file = "power_spectral_density.csv";
    FILE *fp = fopen(csv_file, "w");
    if (!fp) {
        fprintf(stderr, "cannot open %s for writing\n", csv_file);
        return 1;
    }

    fprintf(fp, "bin,frequency_hz,power\n");
    for (unsigned k = 0; k < num_bins; k++) {
        fprintf(fp, "%u,%.4f,%.8f\n", k, freqs[k], psd[k]);
    }
    fclose(fp);

    printf("Wrote %u frequency bins to %s\n", num_bins, csv_file);

    /* ------------------------------------------------------------------
     * Write interactive HTML visualisation (Plotly.js + D3.js)
     * ----------------------------------------------------------------*/
    const char *html_file = "power_spectral_density.html";
    if (write_html(html_file, freqs, psd, num_bins,
                   sample_rate, N, freq1, freq2, freq3) == 0) {
        printf("Wrote interactive plot to %s\n", html_file);
    }

    printf("Signal: %.0f Hz + %.0f Hz + %.0f Hz + DC offset\n",
           freq1, freq2, freq3);
    printf("Sample rate: %.0f Hz, FFT size: %u\n", sample_rate, N);

    /* ------------------------------------------------------------------
     * Cleanup
     * ----------------------------------------------------------------*/
    free(freqs);
    free(psd);
    free(window);
    free(windowed);
    free(signal);
    MD_shutdown();

    return 0;
}
