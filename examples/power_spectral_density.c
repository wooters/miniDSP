/**
 * @file power_spectral_density.c
 * @brief Example: compute and export the power spectral density of a test signal.
 *
 * This program demonstrates MD_power_spectral_density() by:
 *   1. Generating a signal with three sinusoidal components (440 Hz,
 *      1000 Hz, and 2500 Hz) plus a DC offset.
 *   2. Applying a Hanning window to reduce spectral leakage.
 *   3. Computing the PSD via MD_power_spectral_density().
 *   4. Converting to a one-sided PSD (doubling interior bins).
 *   5. Writing the results to CSV and to an interactive HTML visualisation
 *      (Plotly.js + D3.js, no server required).
 *
 * The PSD shows how the signal's *power* is distributed across frequencies,
 * whereas the magnitude spectrum shows *amplitude*.  PSD is especially
 * useful for noise analysis and SNR estimation.
 *
 * Build and run (from the repository root):
 *   make                          # build libminidsp.a first
 *   make -C examples plot         # build example, run it, generate HTML
 *   open examples/power_spectral_density.html   # interactive PSD plot
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "minidsp.h"

/* -----------------------------------------------------------------------
 * Write the interactive HTML visualisation.
 *
 * The HTML file is completely self-contained: PSD data is embedded
 * as JavaScript arrays, and Plotly.js / D3.js are loaded from CDN.
 * Just open the file in any modern browser -- no local server needed.
 * -----------------------------------------------------------------------*/
static int write_html(const char *path,
                      const double *freqs, const double *psd,
                      unsigned num_bins,
                      double sample_rate, unsigned N,
                      double freq1, double freq2, double freq3)
{
    FILE *fp = fopen(path, "w");
    if (!fp) {
        fprintf(stderr, "cannot open %s for writing\n", path);
        return -1;
    }

    /* ---- HTML header & styles ---- */
    fprintf(fp,
        "<!DOCTYPE html>\n"
        "<html lang=\"en\">\n"
        "<head>\n"
        "  <meta charset=\"utf-8\">\n"
        "  <title>Power Spectral Density â€“ miniDSP</title>\n"
        "  <script src=\"https://cdn.plot.ly/plotly-2.35.2.min.js\"></script>\n"
        "  <script src=\"https://d3js.org/d3-array.v3.min.js\"></script>\n"
        "  <style>\n"
        "    * { box-sizing: border-box; margin: 0; padding: 0; }\n"
        "    body {\n"
        "      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\n"
        "      background: #fafafa; color: #222; padding: 1.5rem;\n"
        "    }\n"
        "    h1 { font-size: 1.4rem; margin-bottom: 0.3rem; }\n"
        "    .subtitle {\n"
        "      color: #666; font-size: 0.9rem; margin-bottom: 1.2rem;\n"
        "    }\n"
        "    .plot-container { margin-bottom: 1.5rem; }\n"
        "    .info {\n"
        "      background: #f0f4ff; border-left: 4px solid #2563eb;\n"
        "      padding: 0.8rem 1rem; font-size: 0.85rem; line-height: 1.6;\n"
        "      border-radius: 0 6px 6px 0; max-width: 700px;\n"
        "    }\n"
        "    .info code { background: #e2e8f0; padding: 1px 5px; border-radius: 3px; }\n"
        "  </style>\n"
        "</head>\n"
        "<body>\n"
        "  <h1>Power Spectral Density</h1>\n"
        "  <p class=\"subtitle\">\n"
        "    %.0f Hz + %.0f Hz + %.0f Hz &nbsp;|&nbsp;\n"
        "    sample rate %.0f Hz &nbsp;|&nbsp;\n"
        "    FFT size %u &nbsp;|&nbsp;\n"
        "    Hanning window\n"
        "  </p>\n"
        "  <div id=\"linear-plot\" class=\"plot-container\"></div>\n"
        "  <div id=\"db-plot\" class=\"plot-container\"></div>\n"
        "  <div class=\"info\">\n"
        "    <strong>How to read this plot:</strong><br>\n"
        "    The PSD shows how signal <em>power</em> is distributed across\n"
        "    frequencies.  Each spike corresponds to a sinusoidal component.\n"
        "    The x-axis shows frequency in Hz (bin index &times;\n"
        "    <code>sample_rate / N</code>).  The top plot uses a linear power\n"
        "    scale; the bottom plot uses a logarithmic (dB) scale\n"
        "    (<code>10&middot;log10(PSD)</code>) so you can see low-level details.\n"
        "    Note: PSD uses <code>10&middot;log10</code> (not 20) because it\n"
        "    represents power, not amplitude.\n"
        "  </div>\n\n",
        freq1, freq2, freq3, sample_rate, N);

    /* ---- Embed PSD data as JS arrays ---- */
    fprintf(fp, "  <script>\n");
    fprintf(fp, "    // PSD data generated by power_spectral_density.c\n");

    fprintf(fp, "    const freqs = [");
    for (unsigned k = 0; k < num_bins; k++) {
        fprintf(fp, "%.4f", freqs[k]);
        if (k + 1 < num_bins) fprintf(fp, ",");
    }
    fprintf(fp, "];\n");

    fprintf(fp, "    const psd = [");
    for (unsigned k = 0; k < num_bins; k++) {
        fprintf(fp, "%.8f", psd[k]);
        if (k + 1 < num_bins) fprintf(fp, ",");
    }
    fprintf(fp, "];\n\n");

    /* ---- Plotly + D3 visualisation code ---- */
    fprintf(fp,
        "    // Use D3's d3.max() to compute axis ranges\n"
        "    const maxPSD = d3.max(psd);\n"
        "\n"
        "    // Convert to dB scale: 10*log10(PSD) because PSD is power, not amplitude.\n"
        "    // Floor at -120 dB to avoid log(0).\n"
        "    const psd_db = psd.map(p => 10 * Math.log10(Math.max(p, 1e-12)));\n"
        "\n"
        "    // Find the three peak frequencies for annotation using d3\n"
        "    const peakTargets = [%.0f, %.0f, %.0f];\n"
        "    const annotations_linear = [];\n"
        "    const annotations_db = [];\n"
        "\n"
        "    peakTargets.forEach(target => {\n"
        "      const idx = d3.minIndex(freqs, f => Math.abs(f - target));\n"
        "      annotations_linear.push({\n"
        "        x: freqs[idx], y: psd[idx],\n"
        "        text: target + ' Hz',\n"
        "        showarrow: true, arrowhead: 2,\n"
        "        ax: 40, ay: -30,\n"
        "        font: { size: 12 }\n"
        "      });\n"
        "      annotations_db.push({\n"
        "        x: freqs[idx], y: psd_db[idx],\n"
        "        text: target + ' Hz (' + psd_db[idx].toFixed(1) + ' dB)',\n"
        "        showarrow: true, arrowhead: 2,\n"
        "        ax: 50, ay: -25,\n"
        "        font: { size: 12 }\n"
        "      });\n"
        "    });\n"
        "\n"
        "    // --- Linear PSD plot ---\n"
        "    Plotly.newPlot('linear-plot', [{\n"
        "      x: freqs, y: psd,\n"
        "      type: 'scatter', mode: 'lines',\n"
        "      line: { color: '#2563eb', width: 1.2 },\n"
        "      name: 'PSD',\n"
        "      hovertemplate: '%%{x:.1f} Hz<br>Power: %%{y:.6f}<extra></extra>'\n"
        "    }], {\n"
        "      title: { text: 'Linear Scale', font: { size: 15 } },\n"
        "      xaxis: { title: 'Frequency (Hz)', range: [0, d3.max(freqs)] },\n"
        "      yaxis: { title: 'Power', range: [0, maxPSD * 1.1] },\n"
        "      annotations: annotations_linear,\n"
        "      margin: { t: 50, r: 30, b: 50, l: 60 },\n"
        "      height: 320\n"
        "    }, { responsive: true });\n"
        "\n"
        "    // --- dB PSD plot ---\n"
        "    Plotly.newPlot('db-plot', [{\n"
        "      x: freqs, y: psd_db,\n"
        "      type: 'scatter', mode: 'lines',\n"
        "      line: { color: '#dc2626', width: 1.2 },\n"
        "      name: '10\\u00b7log\\u2081\\u2080(PSD)',\n"
        "      hovertemplate: '%%{x:.1f} Hz<br>%%{y:.1f} dB<extra></extra>'\n"
        "    }], {\n"
        "      title: { text: 'Logarithmic (dB) Scale', font: { size: 15 } },\n"
        "      xaxis: { title: 'Frequency (Hz)', range: [0, d3.max(freqs)] },\n"
        "      yaxis: { title: 'Power (dB)', range: [-80, 5] },\n"
        "      annotations: annotations_db,\n"
        "      margin: { t: 50, r: 30, b: 50, l: 60 },\n"
        "      height: 320\n"
        "    }, { responsive: true });\n"
        "  </script>\n"
        "</body>\n"
        "</html>\n",
        freq1, freq2, freq3);

    fclose(fp);
    return 0;
}

int main(void)
{
    /* ------------------------------------------------------------------
     * Signal parameters
     * ----------------------------------------------------------------*/
    const unsigned   N           = 4096;        /* FFT size (samples)       */
    const double     sample_rate = 16000.0;     /* Hz                       */
    const unsigned   num_bins    = N / 2 + 1;   /* unique frequency bins    */

    /* Three tones at different amplitudes, plus a small DC offset */
    const double     freq1 =  440.0;   /* A4 note               */
    const double     amp1  =    1.0;
    const double     freq2 = 1000.0;   /* 1 kHz reference tone  */
    const double     amp2  =    0.6;
    const double     freq3 = 2500.0;   /* higher partial        */
    const double     amp3  =    0.3;
    const double     dc    =    0.1;   /* small DC offset       */

    /* ------------------------------------------------------------------
     * Generate the test signal
     * ----------------------------------------------------------------*/
    double *signal   = malloc(N * sizeof(double));
    double *windowed = malloc(N * sizeof(double));
    double *window   = malloc(N * sizeof(double));
    double *psd      = malloc(num_bins * sizeof(double));
    double *freqs    = malloc(num_bins * sizeof(double));

    if (!signal || !windowed || !window || !psd || !freqs) {
        fprintf(stderr, "allocation failed\n");
        return 1;
    }

    for (unsigned i = 0; i < N; i++) {
        double t = (double)i / sample_rate;
        signal[i] = dc
                  + amp1 * sin(2.0 * M_PI * freq1 * t)
                  + amp2 * sin(2.0 * M_PI * freq2 * t)
                  + amp3 * sin(2.0 * M_PI * freq3 * t);
    }

    /* ------------------------------------------------------------------
     * Apply a Hanning window to reduce spectral leakage.
     * Windowing tapers the signal edges to zero, preventing the abrupt
     * discontinuity at the FFT frame boundary from smearing energy
     * across all frequency bins.
     * ----------------------------------------------------------------*/
    MD_Gen_Hann_Win(window, N);
    for (unsigned i = 0; i < N; i++) {
        windowed[i] = signal[i] * window[i];
    }

    /* ------------------------------------------------------------------
     * Compute the power spectral density.
     * MD_power_spectral_density() returns PSD[k] = |X(k)|^2 / N.
     * The /N normalisation is already done inside the function.
     * ----------------------------------------------------------------*/
    MD_power_spectral_density(windowed, N, psd);

    /* Convert to one-sided PSD:
     *   - Double the interior bins (k = 1..N/2-1) because negative
     *     frequencies are folded onto the positive side.
     *   - DC (k=0) and Nyquist (k=N/2) are not doubled -- they have
     *     no mirror image.
     * Note: we do NOT divide by N again -- the function already did that. */
    for (unsigned k = 0; k < num_bins; k++) {
        freqs[k] = (double)k * sample_rate / (double)N;
        if (k > 0 && k < N / 2) {
            psd[k] *= 2.0;
        }
    }

    /* ------------------------------------------------------------------
     * Write results to CSV (for data interchange)
     * ----------------------------------------------------------------*/
    const char *csv_file = "power_spectral_density.csv";
    FILE *fp = fopen(csv_file, "w");
    if (!fp) {
        fprintf(stderr, "cannot open %s for writing\n", csv_file);
        return 1;
    }

    fprintf(fp, "bin,frequency_hz,power\n");
    for (unsigned k = 0; k < num_bins; k++) {
        fprintf(fp, "%u,%.4f,%.8f\n", k, freqs[k], psd[k]);
    }
    fclose(fp);

    printf("Wrote %u frequency bins to %s\n", num_bins, csv_file);

    /* ------------------------------------------------------------------
     * Write interactive HTML visualisation (Plotly.js + D3.js)
     * ----------------------------------------------------------------*/
    const char *html_file = "power_spectral_density.html";
    if (write_html(html_file, freqs, psd, num_bins,
                   sample_rate, N, freq1, freq2, freq3) == 0) {
        printf("Wrote interactive plot to %s\n", html_file);
    }

    printf("Signal: %.0f Hz + %.0f Hz + %.0f Hz + DC offset\n",
           freq1, freq2, freq3);
    printf("Sample rate: %.0f Hz, FFT size: %u\n", sample_rate, N);

    /* ------------------------------------------------------------------
     * Cleanup
     * ----------------------------------------------------------------*/
    free(freqs);
    free(psd);
    free(window);
    free(windowed);
    free(signal);
    MD_shutdown();

    return 0;
}
